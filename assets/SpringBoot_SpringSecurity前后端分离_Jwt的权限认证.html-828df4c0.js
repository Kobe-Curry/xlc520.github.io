const e=JSON.parse('{"key":"v-47bb6d4c","path":"/dev/SpringBoot_SpringSecurity%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB_Jwt%E7%9A%84%E6%9D%83%E9%99%90%E8%AE%A4%E8%AF%81.html","title":"SpringBoot+SpringSecurity前后端分离+Jwt的权限认证","lang":"zh-CN","frontmatter":{"author":"xlc520","title":"SpringBoot+SpringSecurity前后端分离+Jwt的权限认证","description":"SpringBoot+SpringSecurity前后端分离+Jwt的权限认证","date":"2022-02-13T00:00:00.000Z","category":["Java"],"tag":["Java"],"article":true,"timeline":true,"icon":"type","password":null,"head":[["meta",{"property":"og:url","content":"https://blog.ciberviler.top/dev/SpringBoot_SpringSecurity%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB_Jwt%E7%9A%84%E6%9D%83%E9%99%90%E8%AE%A4%E8%AF%81.html"}],["meta",{"property":"og:site_name","content":"StudyNote"}],["meta",{"property":"og:title","content":"SpringBoot+SpringSecurity前后端分离+Jwt的权限认证"}],["meta",{"property":"og:description","content":"SpringBoot+SpringSecurity前后端分离+Jwt的权限认证"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:updated_time","content":"2023-01-21T05:51:00.000Z"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"xlc520"}],["meta",{"property":"article:tag","content":"Java"}],["meta",{"property":"article:published_time","content":"2022-02-13T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-01-21T05:51:00.000Z"}]]},"headers":[{"level":2,"title":"前言","slug":"前言","link":"#前言","children":[]},{"level":2,"title":"一、五个handler一个filter两个User","slug":"一、五个handler一个filter两个user","link":"#一、五个handler一个filter两个user","children":[{"level":3,"title":"1.1 AuthenticationEntryPoint","slug":"_1-1-authenticationentrypoint","link":"#_1-1-authenticationentrypoint","children":[]},{"level":3,"title":"1.2 AuthenticationSuccessHandler","slug":"_1-2-authenticationsuccesshandler","link":"#_1-2-authenticationsuccesshandler","children":[]},{"level":3,"title":"1.3 AuthenticationFailureHandler","slug":"_1-3-authenticationfailurehandler","link":"#_1-3-authenticationfailurehandler","children":[]},{"level":3,"title":"1.4 LogoutSuccessHandler","slug":"_1-4-logoutsuccesshandler","link":"#_1-4-logoutsuccesshandler","children":[]},{"level":3,"title":"1.5 AccessDeniedHandler","slug":"_1-5-accessdeniedhandler","link":"#_1-5-accessdeniedhandler","children":[]},{"level":3,"title":"1.6 一个过滤器OncePerRequestFilter","slug":"_1-6-一个过滤器onceperrequestfilter","link":"#_1-6-一个过滤器onceperrequestfilter","children":[]},{"level":3,"title":"1.7 实现UserDetails扩充字段","slug":"_1-7-实现userdetails扩充字段","link":"#_1-7-实现userdetails扩充字段","children":[]},{"level":3,"title":"1.8 实现UserDetailsService","slug":"_1-8-实现userdetailsservice","link":"#_1-8-实现userdetailsservice","children":[]},{"level":3,"title":"1.9 userSessionService","slug":"_1-9-usersessionservice","link":"#_1-9-usersessionservice","children":[]},{"level":3,"title":"1.10 ResonseUtil","slug":"_1-10-resonseutil","link":"#_1-10-resonseutil","children":[]}]},{"level":2,"title":"二、配置WebSecurityConfigurerAdapter","slug":"二、配置websecurityconfigureradapter","link":"#二、配置websecurityconfigureradapter","children":[]},{"level":2,"title":"三、其他","slug":"三、其他","link":"#三、其他","children":[{"level":3,"title":"3.1 不足之处","slug":"_3-1-不足之处","link":"#_3-1-不足之处","children":[]},{"level":3,"title":"3.2 解决","slug":"_3-2-解决","link":"#_3-2-解决","children":[]}]}],"git":{"createdTime":1668948234000,"updatedTime":1674280260000,"contributors":[{"name":"xlc520","email":"2215400217@qq.com","commits":2}]},"readingTime":{"minutes":14.97,"words":4492},"filePathRelative":"dev/SpringBoot+SpringSecurity前后端分离+Jwt的权限认证.md","localizedDate":"2022年2月13日","excerpt":"<h1> SpringBoot+SpringSecurity前后端分离+Jwt的权限认证</h1>\\n<h2> 前言</h2>\\n<p>一般来说，我们用SpringSecurity默认的话是前后端整在一起的，比如thymeleaf或者Freemarker，SpringSecurity还自带login登录页,还让你配置登出页,错误页。\\n但是现在前后端分离才是正道，前后端分离的话，那就需要将返回的页面换成Json格式交给前端处理了</p>\\n<p>SpringSecurity默认的是采用Session来判断请求的用户是否登录的，但是不方便分布式的扩展，虽然SpringSecurity也支持采用SpringSession来管理分布式下的用户状态，不过现在分布式的还是无状态的Jwt比较主流。 所以下面说下怎么让SpringSecurity变成前后端分离，采用Jwt来做认证的</p>"}');export{e as data};
